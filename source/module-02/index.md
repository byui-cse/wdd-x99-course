---
title: Module 02: Overview
body-class: index-page
---

![Monolithic App]({{URLROOT}}/shared/img/technology-product-development-sprint2.jpg)
*[Photo by Dall-E-3](https://openai.com/dall-e-3)*

## Module 02 - From Facade to Function - Building your MVP

Now that you've completed your Design Sprint and gathered real customer feedback, it's time to take the next big step: building your *Minimum Viable Product (MVP)*. Your MVP is not a rough draft or an early version of your final product‚Äîit's the *smallest possible product that delivers real value to users* and gives you *real learning about your product‚Äôs potential*.

This sprint is about moving from assumptions to evidence-based development. You‚Äôll take what you learned from testing your facade prototype and make intentional decisions about what to build, what to change, and what to drop. If your product didn‚Äôt resonate with users during the design sprint, that‚Äôs okay‚Äîin fact, that‚Äôs expected. In this case, you‚Äôll return to the drawing board and run a *second, smaller design sprint*. This way, you can be confident you‚Äôre not wasting engineering time on features no one wants.

From here on out, your team will follow an *agile workflow* (Note: While there are valid use cases for the Waterfall approach, this course will focus exclusively on Agile methods.) That means stand-ups at the beginning of each class, sprint planning, and continuous collaboration. Your focus should always be on *solving real user problems*, not just shipping features.

!!! time "5 Keys to Agile Development"

    1. **Work in Iterations (Sprints)**: Agile breaks work into short, focused time periods called sprints (in our case, two weeks). You don‚Äôt need to build everything at once. You just need to make progress you can test, show, and learn from.

    1. **Deliver Incrementally**: Each sprint should end with something usable, testable, or interactive‚Äîeven if it's just a small piece. You‚Äôre building a product step by step, not waiting until the last week to show progress.

    1. **Solve Real Problems, Not Just Build Features**: Agile is about creating value. Ask yourself: ‚ÄúWhat problem is this solving for the user?‚Äù If you can‚Äôt answer that, you may be building the wrong thing.

    1. **Collaborate Constantly**: Agile teams communicate early and often. You‚Äôll make faster progress by checking in regularly, sharing blockers, and asking for help instead of working in silence.

    1. **Adapt and Learn**: Agile expects things to change. Customer feedback, new ideas, or technical challenges may shift your direction‚Äîand that‚Äôs okay. The goal is to learn quickly and improve.

## Key Goals for Sprint 2:

* Build a functional MVP based on validated customer needs
* Integrate meaningful feedback from your initial prototype
* Start using agile practices for planning and progress tracking
* Continue validating your product with real users

## TODO Items for this Module:

### Product Manager

* Recruit 5 new customers (in addition to previous testers) for usability testing at the end of this sprint
* Write lightweight problem statements for any new functionality the team is considering
* Maintain a living backlog of hypotheses to validate and customer pain points

### Tech Lead

* Create and maintain a Git repository; ensure all team members have access
* Set up a Trello, Jira, or GitHub Projects board for organizing sprint tasks
* Collaborate closely with design and PM to scope what is technically feasible within the sprint

### Product Designer

* Update interface and interaction designs based on customer feedback
* Build out user flows that reflect changes to the product vision
* Work with the Tech Lead to ensure designs are realistic and buildable within the sprint

### Full Team

* Identify and estimate tasks needed to build a working MVP
* Focus on problem-solution fit: Does what we‚Äôre building actually solve the user‚Äôs problem?
* Use a stand-up format at the start of each class (What did you do? What are you doing? Any blockers?)
* Prioritize outcomes, not features: Why are we building this, and how will we know it‚Äôs successful?
* Start Building!!! 

!!! time "How to Run a Stand-Up Meeting (Daily Check-In)"

    A stand-up is a quick, focused meeting (5‚Äì10 minutes) at the start of class where every team member answers three simple questions:

    * What did I work on last time?
    * What am I working on today?
    * Do I have any blockers? (Anything slowing me down?)

    üí° Tips:

    * Everyone stands (if in person) to keep it brief and focused.
    * Be honest‚Äîthis isn‚Äôt a report for the teacher, it's for the team.
    * Keep it short. If a longer discussion is needed, save it for after the stand-up.

## SVPG Product Mindset to Embrace This Sprint:

!!! note "Silicon Valley Product Group"

    We'll be using ideas from [*Silicon Valley Product Group (SVPG)*](https://www.svpg.com) in this course. SVPG is made up of some of the most experienced and respected product leaders in the tech industry. Their mission is to share proven principles and practices that help teams build products customers love. Unlike traditional approaches that separate planning, design, and engineering, SVPG emphasizes deep collaboration across roles, constant discovery, and building only what adds real value. Their philosophy helps teams avoid wasting time on features nobody uses and instead focus on solving meaningful problems in ways that are usable, valuable, and feasible. In this course, we‚Äôll be drawing on SVPG‚Äôs ideas to help you build smarter, faster, and more customer-focused products.

* *Product Discovery never stops* ‚Äì keep talking to customers even while building
* *Good products solve hard problems in valuable ways* ‚Äì don‚Äôt just aim for ‚Äúdone,‚Äù aim for ‚Äúimpactful‚Äù
* *Engineers, Designers, and Product Managers are co-owners of product success* ‚Äì decisions should never be siloed
* *The team is empowered* to identify how to solve a problem; *they also bear the responsibility* of how well that solution solves the needs of the customer.

## The Software Development Lifecycle ‚Äî with a Product Mindset

The *Software Development Lifecycle (SDLC)* provides a structured approach to building software, outlining key phases such as planning, design, development, testing, deployment, and maintenance. In this course, we'll follow the SDLC not as a rigid checklist, but as a *flexible framework* for thoughtful, iterative product development. Inspired by the Silicon Valley Product Group, we‚Äôll treat these stages as *highly collaborative and customer-driven*. That means planning isn‚Äôt just for product managers, design doesn‚Äôt end when mockups are approved, and engineering isn‚Äôt just about writing code‚Äîit‚Äôs about discovering the best solution together. Instead of throwing requirements over the wall, teams will continuously learn, adapt, and validate their ideas with real users as they move through each phase.

!!! warning "Over the Wall"

    Too often, product teams are handed a list of pre-defined features or requirements and told to build them‚Äîno questions asked. Since the team didn‚Äôt help shape those requirements or understand the underlying problems, they have little ownership over the outcome. If the feature fails to deliver value, the blame falls on ‚Äúbad requirements,‚Äù not the team. This *‚Äúthrow it over the wall‚Äù* approach creates silos and leads to wasted effort, poor products, and demoralized teams.

    We avoid this at all costs.

    Instead, we want teams to be *empowered to solve problems*, not just deliver features. That means engineers, designers, and product managers work together from the beginning to deeply understand customer pain points, explore solutions, and validate ideas before building. When teams are trusted to own outcomes‚Äînot just deliverables‚Äîthey make better decisions, take pride in their work, and build products that actually matter.

## SDLC with a Modern Product Approach:

* *Planning:* Identify real customer problems through continuous discovery
* *Design:* Collaborate on lightweight, testable prototypes before investing in full builds
* *Development:* Build incrementally, prioritizing usability and business value
* *Testing:* Test early and often‚Äîuse both automated tests and real customer feedback
* *Deployment:* Ship early and frequently to learn from real-world usage
* *Maintenance:* Refine based on user behavior and emerging insights (start the process over again)